import {
  users,
  customers,
  products,
  segments,
  campaigns,
  aiAnalyses,
  aiCustomerPredictions,
  type User,
  type UpsertUser,
  type Customer,
  type InsertCustomer,
  type Product,
  type InsertProduct,
  type Segment,
  type InsertSegment,
  type Campaign,
  type InsertCampaign,
  type AiAnalysis,
  type InsertAiAnalysis,
  type AiCustomerPrediction,
  type InsertAiCustomerPrediction,
} from "@shared/schema";
import { db } from "./db";
import { eq, sql, and, gte, lte, like, ilike, or, inArray } from "drizzle-orm";

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  
  getAllCustomers(): Promise<Customer[]>;
  getCustomer(id: string): Promise<Customer | undefined>;
  getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined>;
  createCustomer(customer: InsertCustomer): Promise<Customer>;
  updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer>;
  upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }>;
  getCustomersWithRenewalIn30Days(): Promise<Customer[]>;
  getCustomersByIds(ids: string[]): Promise<Customer[]>;
  getCustomerCount(): Promise<number>;
  deleteAllCustomers(): Promise<void>;
  
  getAllProducts(): Promise<Product[]>;
  getProduct(id: string): Promise<Product | undefined>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product>;
  deleteProduct(id: string): Promise<void>;
  getProductCustomerCounts(): Promise<Record<string, number>>;
  
  getAllSegments(): Promise<Segment[]>;
  getSegment(id: string): Promise<Segment | undefined>;
  createSegment(segment: InsertSegment): Promise<Segment>;
  updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment>;
  deleteSegment(id: string): Promise<void>;
  deleteAutoGeneratedSegments(): Promise<void>;
  
  getAllCampaigns(): Promise<Campaign[]>;
  getCampaign(id: string): Promise<Campaign | undefined>;
  createCampaign(campaign: InsertCampaign): Promise<Campaign>;
  updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign>;
  deleteCampaign(id: string): Promise<void>;
  
  getAllAiAnalyses(): Promise<AiAnalysis[]>;
  createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis>;
  deleteAiAnalysesByType(analysisType: string): Promise<void>;
  
  getCustomerPredictions(filters: {
    analysisType?: string;
    minProbability?: number;
    maxProbability?: number;
    search?: string;
    product?: string;
    city?: string;
  }): Promise<AiCustomerPrediction[]>;
  getCustomerPredictionsByCustomerId(customerId: string): Promise<AiCustomerPrediction[]>;
  createCustomerPredictions(predictions: InsertAiCustomerPrediction[]): Promise<AiCustomerPrediction[]>;
  deleteCustomerPredictionsByType(analysisType: string): Promise<void>;
  
  getCustomersPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    branch?: string;
    segment?: string;
    renewalDays?: number;
    aiPredictionType?: string;
    aiAnalysisId?: string;
    customerType?: string;
    dateType?: string;
    dateFrom?: string;
    dateTo?: string;
    hasBranch?: string;
    notHasBranch?: string;
    minAge?: number;
  }): Promise<{ customers: Customer[]; total: number; page: number; totalPages: number }>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  async getAllCustomers(): Promise<Customer[]> {
    return await db.select().from(customers).orderBy(customers.musteriIsmi);
  }

  async getCustomer(id: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.id, id));
    return customer;
  }

  async getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.tcKimlikNo, tcKimlik));
    return customer;
  }

  async createCustomer(customer: InsertCustomer): Promise<Customer> {
    const [newCustomer] = await db.insert(customers).values(customer).returning();
    return newCustomer;
  }

  async updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer> {
    const [updated] = await db
      .update(customers)
      .set({ ...customer, updatedAt: new Date() })
      .where(eq(customers.id, id))
      .returning();
    return updated;
  }

  async upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }> {
    if (!customer.tcKimlikNo) {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }

    const existing = await this.getCustomerByTcKimlik(customer.tcKimlikNo);
    if (existing) {
      const updated = await this.updateCustomer(existing.id, customer);
      return { customer: updated, isNew: false };
    } else {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }
  }

  async getCustomersWithRenewalIn30Days(): Promise<Customer[]> {
    const today = new Date();
    const thirtyDaysLater = new Date();
    thirtyDaysLater.setDate(today.getDate() + 30);

    return await db
      .select()
      .from(customers)
      .where(
        and(
          gte(customers.bitisTarihi, today.toISOString().split("T")[0]),
          lte(customers.bitisTarihi, thirtyDaysLater.toISOString().split("T")[0])
        )
      );
  }

  async getCustomersByIds(ids: string[]): Promise<Customer[]> {
    if (ids.length === 0) return [];
    return await db.select().from(customers).where(inArray(customers.id, ids));
  }

  async getCustomerCount(): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` }).from(customers);
    return Number(result[0]?.count || 0);
  }

  async deleteAllCustomers(): Promise<void> {
    await db.delete(customers);
  }

  async getAllProducts(): Promise<Product[]> {
    return await db.select().from(products).orderBy(products.name);
  }

  async getProduct(id: string): Promise<Product | undefined> {
    const [product] = await db.select().from(products).where(eq(products.id, id));
    return product;
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    const [newProduct] = await db.insert(products).values(product).returning();
    return newProduct;
  }

  async updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product> {
    const [updated] = await db
      .update(products)
      .set({ ...product, updatedAt: new Date() })
      .where(eq(products.id, id))
      .returning();
    return updated;
  }

  async deleteProduct(id: string): Promise<void> {
    await db.delete(products).where(eq(products.id, id));
  }

  async getProductCustomerCounts(): Promise<Record<string, number>> {
    const result = await db
      .select({
        anaBrans: customers.anaBrans,
        count: sql<number>`count(*)`,
      })
      .from(customers)
      .groupBy(customers.anaBrans);

    const counts: Record<string, number> = {};
    for (const row of result) {
      if (row.anaBrans) {
        counts[row.anaBrans] = Number(row.count);
      }
    }
    return counts;
  }

  async getAllSegments(): Promise<Segment[]> {
    return await db.select().from(segments).orderBy(segments.createdAt);
  }

  async getSegment(id: string): Promise<Segment | undefined> {
    const [segment] = await db.select().from(segments).where(eq(segments.id, id));
    return segment;
  }

  async createSegment(segment: InsertSegment): Promise<Segment> {
    const [newSegment] = await db.insert(segments).values(segment).returning();
    return newSegment;
  }

  async updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment> {
    const [updated] = await db
      .update(segments)
      .set({ ...segment, updatedAt: new Date() })
      .where(eq(segments.id, id))
      .returning();
    return updated;
  }

  async deleteSegment(id: string): Promise<void> {
    await db.delete(segments).where(eq(segments.id, id));
  }

  async deleteAutoGeneratedSegments(): Promise<void> {
    await db.delete(segments).where(eq(segments.isAutoGenerated, true));
  }

  async getAllCampaigns(): Promise<Campaign[]> {
    return await db.select().from(campaigns).orderBy(campaigns.createdAt);
  }

  async getCampaign(id: string): Promise<Campaign | undefined> {
    const [campaign] = await db.select().from(campaigns).where(eq(campaigns.id, id));
    return campaign;
  }

  async createCampaign(campaign: InsertCampaign): Promise<Campaign> {
    const [newCampaign] = await db.insert(campaigns).values(campaign).returning();
    return newCampaign;
  }

  async updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign> {
    const [updated] = await db
      .update(campaigns)
      .set({ ...campaign, updatedAt: new Date() })
      .where(eq(campaigns.id, id))
      .returning();
    return updated;
  }

  async deleteCampaign(id: string): Promise<void> {
    await db.delete(campaigns).where(eq(campaigns.id, id));
  }

  async getAllAiAnalyses(): Promise<AiAnalysis[]> {
    return await db.select().from(aiAnalyses).where(eq(aiAnalyses.isActive, true));
  }

  async createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis> {
    const [newAnalysis] = await db.insert(aiAnalyses).values(analysis).returning();
    return newAnalysis;
  }

  async deleteAiAnalysesByType(analysisType: string): Promise<void> {
    await db.delete(aiAnalyses).where(eq(aiAnalyses.analysisType, analysisType));
  }

  async getCustomerPredictions(filters: {
    analysisType?: string;
    minProbability?: number;
    maxProbability?: number;
    search?: string;
    product?: string;
    city?: string;
  }): Promise<AiCustomerPrediction[]> {
    const conditions = [];
    
    if (filters.analysisType) {
      conditions.push(eq(aiCustomerPredictions.analysisType, filters.analysisType));
    }
    if (filters.minProbability !== undefined) {
      conditions.push(gte(aiCustomerPredictions.probability, filters.minProbability));
    }
    if (filters.maxProbability !== undefined) {
      conditions.push(lte(aiCustomerPredictions.probability, filters.maxProbability));
    }
    if (filters.search) {
      conditions.push(like(aiCustomerPredictions.customerName, `%${filters.search}%`));
    }
    if (filters.product) {
      conditions.push(eq(aiCustomerPredictions.currentProduct, filters.product));
    }
    if (filters.city) {
      conditions.push(eq(aiCustomerPredictions.city, filters.city));
    }

    if (conditions.length === 0) {
      return await db.select().from(aiCustomerPredictions).orderBy(sql`${aiCustomerPredictions.probability} DESC`);
    }
    
    return await db
      .select()
      .from(aiCustomerPredictions)
      .where(and(...conditions))
      .orderBy(sql`${aiCustomerPredictions.probability} DESC`);
  }

  async getCustomerPredictionsByCustomerId(customerId: string): Promise<AiCustomerPrediction[]> {
    return await db
      .select()
      .from(aiCustomerPredictions)
      .where(eq(aiCustomerPredictions.customerId, customerId))
      .orderBy(sql`${aiCustomerPredictions.probability} DESC`);
  }

  async createCustomerPredictions(predictions: InsertAiCustomerPrediction[]): Promise<AiCustomerPrediction[]> {
    if (predictions.length === 0) return [];
    return await db.insert(aiCustomerPredictions).values(predictions).returning();
  }

  async deleteCustomerPredictionsByType(analysisType: string): Promise<void> {
    await db.delete(aiCustomerPredictions).where(eq(aiCustomerPredictions.analysisType, analysisType));
  }

  async getCustomersPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    branch?: string;
    segment?: string;
    renewalDays?: number;
    aiPredictionType?: string;
    aiAnalysisId?: string;
    customerType?: string;
    dateType?: string;
    dateFrom?: string;
    dateTo?: string;
    hasBranch?: string;
    notHasBranch?: string;
    minAge?: number;
  }): Promise<{ customers: Customer[]; total: number; page: number; totalPages: number }> {
    const conditions = [];
    
    // Renewal filter - policies expiring within X days (null-safe, timezone-aware)
    if (filters.renewalDays) {
      conditions.push(
        and(
          sql`${customers.bitisTarihi} IS NOT NULL`,
          sql`${customers.bitisTarihi}::date >= CURRENT_DATE`,
          sql`${customers.bitisTarihi}::date <= CURRENT_DATE + ${filters.renewalDays}::integer`
        )
      );
    }
    
    // AI Prediction filter - use EXISTS subquery for efficiency
    if (filters.aiPredictionType) {
      conditions.push(
        sql`EXISTS (
          SELECT 1 FROM ${aiCustomerPredictions} 
          WHERE ${aiCustomerPredictions.customerId} = ${customers.id} 
          AND ${aiCustomerPredictions.analysisType} = ${filters.aiPredictionType}
        )`
      );
    }
    
    // AI Analysis filter - filter by customer IDs stored in the analysis
    if (filters.aiAnalysisId) {
      conditions.push(
        sql`${customers.id}::text IN (
          SELECT jsonb_array_elements_text(customer_ids) 
          FROM ai_analyses 
          WHERE id = ${filters.aiAnalysisId} AND customer_ids IS NOT NULL
        )`
      );
    }

    if (filters.search) {
      conditions.push(
        or(
          like(customers.musteriIsmi, `%${filters.search}%`),
          like(customers.tcKimlikNo, `%${filters.search}%`),
          like(customers.gsmNo, `%${filters.search}%`)
        )
      );
    }
    if (filters.city) {
      conditions.push(eq(customers.sehir, filters.city));
    }
    if (filters.branch) {
      conditions.push(eq(customers.anaBrans, filters.branch));
    }
    
    // Customer type filter (kurumsal/bireysel)
    if (filters.customerType) {
      if (filters.customerType === "kurumsal") {
        conditions.push(like(customers.musteriTipi, `%Kurumsal%`));
      } else if (filters.customerType === "bireysel") {
        conditions.push(like(customers.musteriTipi, `%Bireysel%`));
      }
    }
    
    // Date range filter
    if (filters.dateType && (filters.dateFrom || filters.dateTo)) {
      const dateColumn = 
        filters.dateType === "policeBitis" ? customers.bitisTarihi :
        filters.dateType === "policeBaslangic" ? customers.baslangicTarihi :
        customers.tanzimTarihi;
      
      if (filters.dateFrom) {
        conditions.push(sql`${dateColumn}::date >= ${filters.dateFrom}::date`);
      }
      if (filters.dateTo) {
        conditions.push(sql`${dateColumn}::date <= ${filters.dateTo}::date`);
      }
    }
    
    if (filters.segment) {
      const segmentLower = filters.segment.toLowerCase().replace(/i̇/g, 'i').replace(/ı/g, 'i');
      console.log("[DEBUG] Segment filter raw:", filters.segment, "-> normalized:", segmentLower);
      const segmentConditions: any[] = [];
      
      // Müşteri tipi filtreleme
      if (segmentLower.includes("kurumsal") || segmentLower.includes("tüzel")) {
        segmentConditions.push(like(customers.musteriTipi, `%Kurumsal%`));
      }
      if (segmentLower.includes("bireysel") || segmentLower.includes("gerçek")) {
        segmentConditions.push(like(customers.musteriTipi, `%Bireysel%`));
      }
      
      // Branş filtreleme - daha geniş eşleştirme
      if (segmentLower.includes("trafik")) {
        segmentConditions.push(like(customers.anaBrans, `%Trafik%`));
      }
      if (segmentLower.includes("kasko")) {
        segmentConditions.push(like(customers.anaBrans, `%Kasko%`));
      }
      if (segmentLower.includes("oto") && !segmentLower.includes("otomot")) {
        segmentConditions.push(like(customers.anaBrans, `%Oto%`));
      }
      if (segmentLower.includes("saglik") || segmentLower.includes("sağlık") || segmentLower.includes("saglık")) {
        segmentConditions.push(ilike(customers.anaBrans, `%sa%l%k%`));
      }
      if (segmentLower.includes("dask")) {
        segmentConditions.push(like(customers.anaBrans, `%Dask%`));
        segmentConditions.push(like(customers.anaBrans, `%DASK%`));
      }
      if (segmentLower.includes("yangin") || segmentLower.includes("yangın") || segmentLower.includes("konut")) {
        segmentConditions.push(like(customers.anaBrans, `%Yangın%`));
        segmentConditions.push(like(customers.anaBrans, `%Yang?n%`));
        segmentConditions.push(like(customers.anaBrans, `%Konut%`));
      }
      if (segmentLower.includes("muhendislik") || segmentLower.includes("mühendislik") || segmentLower.includes("insaat") || segmentLower.includes("inşaat")) {
        segmentConditions.push(like(customers.anaBrans, `%Mühendislik%`));
        segmentConditions.push(like(customers.anaBrans, `%Mühendis%`));
      }
      if (segmentLower.includes("seyahat")) {
        segmentConditions.push(like(customers.anaBrans, `%Seyahat%`));
      }
      if (segmentLower.includes("nakliyat")) {
        segmentConditions.push(like(customers.anaBrans, `%Nakliyat%`));
      }
      if (segmentLower.includes("isyeri") || segmentLower.includes("işyeri")) {
        segmentConditions.push(like(customers.anaBrans, `%İşyeri%`));
        segmentConditions.push(like(customers.anaBrans, `%Isyeri%`));
      }
      if (segmentLower.includes("ferdi") || segmentLower.includes("kaza")) {
        segmentConditions.push(like(customers.anaBrans, `%Ferdi%`));
        segmentConditions.push(like(customers.anaBrans, `%Kaza%`));
      }
      
      console.log("[DEBUG] Segment conditions count:", segmentConditions.length);
      if (segmentConditions.length > 0) {
        conditions.push(or(...segmentConditions));
      }
    }
    
    // Has branch filter - customers who have this product/branch
    // Uses tcKimlikNo to group policies by customer
    if (filters.hasBranch) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND ${customers.tcKimlikNo} IN (
          SELECT tc_kimlik_no FROM customers 
          WHERE ana_brans ILIKE ${`%${filters.hasBranch}%`} AND tc_kimlik_no IS NOT NULL
        )`
      );
    }
    
    // Not has branch filter - customers who do NOT have this product/branch
    // Uses NOT EXISTS instead of NOT IN to handle NULL values properly
    if (filters.notHasBranch) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND NOT EXISTS (
          SELECT 1 FROM customers c2 
          WHERE c2.tc_kimlik_no = ${customers.tcKimlikNo}
          AND c2.ana_brans ILIKE ${`%${filters.notHasBranch}%`}
        )`
      );
    }
    
    // Age filter - customers older than X years based on dogumTarihi
    if (filters.minAge) {
      conditions.push(
        sql`${customers.dogumTarihi} IS NOT NULL AND 
            date_part('year', age(CURRENT_DATE, ${customers.dogumTarihi}::date)) >= ${filters.minAge}`
      );
    }

    const offset = (filters.page - 1) * filters.limit;
    
    const countResult = await db
      .select({ count: sql<number>`count(*)` })
      .from(customers)
      .where(conditions.length > 0 ? and(...conditions) : undefined);
    
    const total = Number(countResult[0]?.count || 0);
    
    const data = await db
      .select()
      .from(customers)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(customers.musteriIsmi)
      .limit(filters.limit)
      .offset(offset);

    return {
      customers: data,
      total,
      page: filters.page,
      totalPages: Math.ceil(total / filters.limit),
    };
  }
}

export const storage = new DatabaseStorage();
