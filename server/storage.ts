import {
  users,
  customers,
  customerProfiles,
  products,
  segments,
  campaigns,
  aiAnalyses,
  aiCustomerPredictions,
  type User,
  type UpsertUser,
  type Customer,
  type InsertCustomer,
  type CustomerProfile,
  type InsertCustomerProfile,
  type Product,
  type InsertProduct,
  type Segment,
  type InsertSegment,
  type Campaign,
  type InsertCampaign,
  type AiAnalysis,
  type InsertAiAnalysis,
  type AiCustomerPrediction,
  type InsertAiCustomerPrediction,
} from "@shared/schema";
import { db } from "./db";
import { eq, sql, and, gte, lte, like, ilike, or, inArray, isNotNull, isNull, not } from "drizzle-orm";

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  
  getAllCustomers(): Promise<Customer[]>;
  getCustomer(id: string): Promise<Customer | undefined>;
  getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined>;
  createCustomer(customer: InsertCustomer): Promise<Customer>;
  updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer>;
  upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }>;
  getCustomersWithRenewalIn30Days(): Promise<Customer[]>;
  getCustomersByIds(ids: string[]): Promise<Customer[]>;
  getCustomerCount(): Promise<number>;
  deleteAllCustomers(): Promise<void>;
  
  getAllProducts(): Promise<Product[]>;
  getProduct(id: string): Promise<Product | undefined>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product>;
  deleteProduct(id: string): Promise<void>;
  getProductCustomerCounts(): Promise<Record<string, number>>;
  
  getAllSegments(): Promise<Segment[]>;
  getSegment(id: string): Promise<Segment | undefined>;
  createSegment(segment: InsertSegment): Promise<Segment>;
  updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment>;
  deleteSegment(id: string): Promise<void>;
  deleteAutoGeneratedSegments(): Promise<void>;
  
  getAllCampaigns(): Promise<Campaign[]>;
  getCampaign(id: string): Promise<Campaign | undefined>;
  createCampaign(campaign: InsertCampaign): Promise<Campaign>;
  updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign>;
  deleteCampaign(id: string): Promise<void>;
  
  getAllAiAnalyses(): Promise<AiAnalysis[]>;
  createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis>;
  deleteAiAnalysis(id: string): Promise<void>;
  deleteAiAnalysesByType(analysisType: string): Promise<void>;
  
  getCustomerPredictions(filters: {
    analysisType?: string;
    minProbability?: number;
    maxProbability?: number;
    search?: string;
    product?: string;
    city?: string;
  }): Promise<AiCustomerPrediction[]>;
  getCustomerPredictionsByCustomerId(customerId: string): Promise<AiCustomerPrediction[]>;
  createCustomerPredictions(predictions: InsertAiCustomerPrediction[]): Promise<AiCustomerPrediction[]>;
  deleteCustomerPredictionsByType(analysisType: string): Promise<void>;
  deleteCustomerPredictionsByProfileIds(analysisType: string, profileIds: string[]): Promise<void>;
  
  getCustomersPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    branch?: string;
    segment?: string;
    renewalDays?: number;
    aiPredictionType?: string;
    aiAnalysisId?: string;
    customerType?: string;
    dateType?: string;
    dateFrom?: string;
    dateTo?: string;
    hasBranch?: string;
    notHasBranch?: string;
    minAge?: number;
    // Advanced filtering for management reports
    hasBranch2?: string;
    notHasBranch2?: string;
    policyCountMin?: number;
    policyCountMax?: number;
    renewalProduct?: string;
    vehicleCountMin?: number;
    vehicleAgeMax?: number;
  }): Promise<{ customers: Customer[]; total: number; page: number; totalPages: number }>;
  
  // Customer Profiles
  getCustomerProfilesPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    customerType?: string;
    policyType?: string;
    hashtags?: string[];
    product?: string;
    vehicleBrand?: string;
    hasAiAnalysis?: boolean;
    hasBranch?: string;
    notHasBranch?: string;
    policyCountMin?: number;
    policyCountMax?: number;
    vehicleCountMin?: number;
    vehicleAgeMax?: number;
  }): Promise<{ profiles: CustomerProfile[]; total: number; page: number; totalPages: number }>;
  getDistinctPolicyTypes(): Promise<string[]>;
  getCustomerProfile(id: string): Promise<CustomerProfile | undefined>;
  getCustomerProfileByHesapKodu(hesapKodu: string): Promise<CustomerProfile | undefined>;
  getCustomerPolicies(hesapKodu: string): Promise<Customer[]>;
  syncCustomerProfiles(): Promise<{ created: number; updated: number }>;
  updateProfileAiAnalysis(profileId: string, aiAnaliz: string): Promise<void>;
  getAllCustomerProfilesForAiAnalysis(): Promise<CustomerProfile[]>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  async getAllCustomers(): Promise<Customer[]> {
    return await db.select().from(customers).orderBy(customers.musteriIsmi);
  }

  async getCustomer(id: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.id, id));
    return customer;
  }

  async getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.tcKimlikNo, tcKimlik));
    return customer;
  }

  async createCustomer(customer: InsertCustomer): Promise<Customer> {
    const [newCustomer] = await db.insert(customers).values(customer).returning();
    return newCustomer;
  }

  async updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer> {
    const [updated] = await db
      .update(customers)
      .set({ ...customer, updatedAt: new Date() })
      .where(eq(customers.id, id))
      .returning();
    return updated;
  }

  async upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }> {
    if (!customer.tcKimlikNo) {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }

    const existing = await this.getCustomerByTcKimlik(customer.tcKimlikNo);
    if (existing) {
      const updated = await this.updateCustomer(existing.id, customer);
      return { customer: updated, isNew: false };
    } else {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }
  }

  async getCustomersWithRenewalIn30Days(): Promise<Customer[]> {
    const today = new Date();
    const thirtyDaysLater = new Date();
    thirtyDaysLater.setDate(today.getDate() + 30);

    return await db
      .select()
      .from(customers)
      .where(
        and(
          gte(customers.bitisTarihi, today.toISOString().split("T")[0]),
          lte(customers.bitisTarihi, thirtyDaysLater.toISOString().split("T")[0])
        )
      );
  }

  async getCustomersByIds(ids: string[]): Promise<Customer[]> {
    if (ids.length === 0) return [];
    return await db.select().from(customers).where(inArray(customers.id, ids));
  }

  async getCustomerCount(): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` }).from(customers);
    return Number(result[0]?.count || 0);
  }

  async deleteAllCustomers(): Promise<void> {
    await db.delete(customers);
  }

  async getAllProducts(): Promise<Product[]> {
    return await db.select().from(products).orderBy(products.name);
  }

  async getProduct(id: string): Promise<Product | undefined> {
    const [product] = await db.select().from(products).where(eq(products.id, id));
    return product;
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    const [newProduct] = await db.insert(products).values(product).returning();
    return newProduct;
  }

  async updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product> {
    const [updated] = await db
      .update(products)
      .set({ ...product, updatedAt: new Date() })
      .where(eq(products.id, id))
      .returning();
    return updated;
  }

  async deleteProduct(id: string): Promise<void> {
    await db.delete(products).where(eq(products.id, id));
  }

  async getProductCustomerCounts(): Promise<Record<string, number>> {
    const result = await db
      .select({
        anaBrans: customers.anaBrans,
        count: sql<number>`count(*)`,
      })
      .from(customers)
      .groupBy(customers.anaBrans);

    const counts: Record<string, number> = {};
    for (const row of result) {
      if (row.anaBrans) {
        counts[row.anaBrans] = Number(row.count);
      }
    }
    return counts;
  }

  async getAllSegments(): Promise<Segment[]> {
    return await db.select().from(segments).orderBy(segments.createdAt);
  }

  async getSegment(id: string): Promise<Segment | undefined> {
    const [segment] = await db.select().from(segments).where(eq(segments.id, id));
    return segment;
  }

  async createSegment(segment: InsertSegment): Promise<Segment> {
    const [newSegment] = await db.insert(segments).values(segment).returning();
    return newSegment;
  }

  async updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment> {
    const [updated] = await db
      .update(segments)
      .set({ ...segment, updatedAt: new Date() })
      .where(eq(segments.id, id))
      .returning();
    return updated;
  }

  async deleteSegment(id: string): Promise<void> {
    await db.delete(segments).where(eq(segments.id, id));
  }

  async deleteAutoGeneratedSegments(): Promise<void> {
    await db.delete(segments).where(eq(segments.isAutoGenerated, true));
  }

  async getAllCampaigns(): Promise<Campaign[]> {
    return await db.select().from(campaigns).orderBy(campaigns.createdAt);
  }

  async getCampaign(id: string): Promise<Campaign | undefined> {
    const [campaign] = await db.select().from(campaigns).where(eq(campaigns.id, id));
    return campaign;
  }

  async createCampaign(campaign: InsertCampaign): Promise<Campaign> {
    const [newCampaign] = await db.insert(campaigns).values(campaign).returning();
    return newCampaign;
  }

  async updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign> {
    const [updated] = await db
      .update(campaigns)
      .set({ ...campaign, updatedAt: new Date() })
      .where(eq(campaigns.id, id))
      .returning();
    return updated;
  }

  async deleteCampaign(id: string): Promise<void> {
    await db.delete(campaigns).where(eq(campaigns.id, id));
  }

  async getAllAiAnalyses(): Promise<AiAnalysis[]> {
    return await db.select().from(aiAnalyses).where(eq(aiAnalyses.isActive, true));
  }

  async createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis> {
    const [newAnalysis] = await db.insert(aiAnalyses).values(analysis).returning();
    return newAnalysis;
  }

  async deleteAiAnalysis(id: string): Promise<void> {
    await db.delete(aiAnalyses).where(eq(aiAnalyses.id, id));
  }

  async deleteAiAnalysesByType(analysisType: string): Promise<void> {
    await db.delete(aiAnalyses).where(eq(aiAnalyses.analysisType, analysisType));
  }

  async getCustomerPredictions(filters: {
    analysisType?: string;
    minProbability?: number;
    maxProbability?: number;
    search?: string;
    product?: string;
    city?: string;
  }): Promise<AiCustomerPrediction[]> {
    const conditions = [];
    
    if (filters.analysisType) {
      conditions.push(eq(aiCustomerPredictions.analysisType, filters.analysisType));
    }
    if (filters.minProbability !== undefined) {
      conditions.push(gte(aiCustomerPredictions.probability, filters.minProbability));
    }
    if (filters.maxProbability !== undefined) {
      conditions.push(lte(aiCustomerPredictions.probability, filters.maxProbability));
    }
    if (filters.search) {
      conditions.push(like(aiCustomerPredictions.customerName, `%${filters.search}%`));
    }
    if (filters.product) {
      // Use partial matching for normalized product names (e.g., "Kasko" matches "Oto Kaza (Kasko)")
      conditions.push(ilike(aiCustomerPredictions.currentProduct, `%${filters.product}%`));
    }
    if (filters.city) {
      conditions.push(eq(aiCustomerPredictions.city, filters.city));
    }

    if (conditions.length === 0) {
      return await db.select().from(aiCustomerPredictions).orderBy(sql`${aiCustomerPredictions.probability} DESC`);
    }
    
    return await db
      .select()
      .from(aiCustomerPredictions)
      .where(and(...conditions))
      .orderBy(sql`${aiCustomerPredictions.probability} DESC`);
  }

  async getCustomerPredictionsByCustomerId(customerId: string): Promise<AiCustomerPrediction[]> {
    return await db
      .select()
      .from(aiCustomerPredictions)
      .where(eq(aiCustomerPredictions.customerId, customerId))
      .orderBy(sql`${aiCustomerPredictions.probability} DESC`);
  }

  async createCustomerPredictions(predictions: InsertAiCustomerPrediction[]): Promise<AiCustomerPrediction[]> {
    if (predictions.length === 0) return [];
    return await db.insert(aiCustomerPredictions).values(predictions).returning();
  }

  async deleteCustomerPredictionsByType(analysisType: string): Promise<void> {
    await db.delete(aiCustomerPredictions).where(eq(aiCustomerPredictions.analysisType, analysisType));
  }

  async deleteCustomerPredictionsByProfileIds(analysisType: string, profileIds: string[]): Promise<void> {
    if (profileIds.length === 0) return;
    await db.delete(aiCustomerPredictions).where(
      and(
        eq(aiCustomerPredictions.analysisType, analysisType),
        inArray(aiCustomerPredictions.profileId, profileIds)
      )
    );
  }

  async getCustomersPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    branch?: string;
    segment?: string;
    renewalDays?: number;
    aiPredictionType?: string;
    aiAnalysisId?: string;
    customerType?: string;
    dateType?: string;
    dateFrom?: string;
    dateTo?: string;
    hasBranch?: string;
    notHasBranch?: string;
    minAge?: number;
    hasBranch2?: string;
    notHasBranch2?: string;
    policyCountMin?: number;
    policyCountMax?: number;
    renewalProduct?: string;
    vehicleCountMin?: number;
    vehicleAgeMax?: number;
  }): Promise<{ customers: Customer[]; total: number; page: number; totalPages: number }> {
    const conditions = [];
    
    // Renewal filter - policies expiring within X days (null-safe, timezone-aware)
    // Skip if renewalProduct is set (product-specific renewal takes precedence)
    if (filters.renewalDays && !filters.renewalProduct) {
      conditions.push(
        and(
          sql`${customers.bitisTarihi} IS NOT NULL`,
          sql`${customers.bitisTarihi}::date >= CURRENT_DATE`,
          sql`${customers.bitisTarihi}::date <= CURRENT_DATE + ${filters.renewalDays}::integer`
        )
      );
    }
    
    // AI Prediction filter - use EXISTS subquery for efficiency
    if (filters.aiPredictionType) {
      conditions.push(
        sql`EXISTS (
          SELECT 1 FROM ${aiCustomerPredictions} 
          WHERE ${aiCustomerPredictions.customerId} = ${customers.id} 
          AND ${aiCustomerPredictions.analysisType} = ${filters.aiPredictionType}
        )`
      );
    }
    
    // AI Analysis filter - filter by customer IDs stored in the analysis
    if (filters.aiAnalysisId) {
      conditions.push(
        sql`${customers.id}::text IN (
          SELECT jsonb_array_elements_text(customer_ids) 
          FROM ai_analyses 
          WHERE id = ${filters.aiAnalysisId} AND customer_ids IS NOT NULL
        )`
      );
    }

    if (filters.search) {
      conditions.push(
        or(
          like(customers.musteriIsmi, `%${filters.search}%`),
          like(customers.tcKimlikNo, `%${filters.search}%`),
          like(customers.gsmNo, `%${filters.search}%`)
        )
      );
    }
    if (filters.city) {
      conditions.push(eq(customers.sehir, filters.city));
    }
    if (filters.branch) {
      conditions.push(eq(customers.anaBrans, filters.branch));
    }
    
    // Customer type filter (kurumsal/bireysel)
    if (filters.customerType) {
      if (filters.customerType === "kurumsal") {
        conditions.push(like(customers.musteriTipi, `%Kurumsal%`));
      } else if (filters.customerType === "bireysel") {
        conditions.push(like(customers.musteriTipi, `%Bireysel%`));
      }
    }
    
    // Date range filter
    if (filters.dateType && (filters.dateFrom || filters.dateTo)) {
      const dateColumn = 
        filters.dateType === "policeBitis" ? customers.bitisTarihi :
        filters.dateType === "policeBaslangic" ? customers.baslangicTarihi :
        customers.tanzimTarihi;
      
      if (filters.dateFrom) {
        conditions.push(sql`${dateColumn}::date >= ${filters.dateFrom}::date`);
      }
      if (filters.dateTo) {
        conditions.push(sql`${dateColumn}::date <= ${filters.dateTo}::date`);
      }
    }
    
    if (filters.segment) {
      const segmentLower = filters.segment.toLowerCase().replace(/i̇/g, 'i').replace(/ı/g, 'i');
      console.log("[DEBUG] Segment filter raw:", filters.segment, "-> normalized:", segmentLower);
      const segmentConditions: any[] = [];
      
      // Müşteri tipi filtreleme
      if (segmentLower.includes("kurumsal") || segmentLower.includes("tüzel")) {
        segmentConditions.push(like(customers.musteriTipi, `%Kurumsal%`));
      }
      if (segmentLower.includes("bireysel") || segmentLower.includes("gerçek")) {
        segmentConditions.push(like(customers.musteriTipi, `%Bireysel%`));
      }
      
      // Branş filtreleme - daha geniş eşleştirme
      if (segmentLower.includes("trafik")) {
        segmentConditions.push(like(customers.anaBrans, `%Trafik%`));
      }
      if (segmentLower.includes("kasko")) {
        segmentConditions.push(like(customers.anaBrans, `%Kasko%`));
      }
      if (segmentLower.includes("oto") && !segmentLower.includes("otomot")) {
        segmentConditions.push(like(customers.anaBrans, `%Oto%`));
      }
      if (segmentLower.includes("saglik") || segmentLower.includes("sağlık") || segmentLower.includes("saglık")) {
        segmentConditions.push(ilike(customers.anaBrans, `%sa%l%k%`));
      }
      if (segmentLower.includes("dask")) {
        segmentConditions.push(like(customers.anaBrans, `%Dask%`));
        segmentConditions.push(like(customers.anaBrans, `%DASK%`));
      }
      if (segmentLower.includes("yangin") || segmentLower.includes("yangın") || segmentLower.includes("konut")) {
        segmentConditions.push(like(customers.anaBrans, `%Yangın%`));
        segmentConditions.push(like(customers.anaBrans, `%Yang?n%`));
        segmentConditions.push(like(customers.anaBrans, `%Konut%`));
      }
      if (segmentLower.includes("muhendislik") || segmentLower.includes("mühendislik") || segmentLower.includes("insaat") || segmentLower.includes("inşaat")) {
        segmentConditions.push(like(customers.anaBrans, `%Mühendislik%`));
        segmentConditions.push(like(customers.anaBrans, `%Mühendis%`));
      }
      if (segmentLower.includes("seyahat")) {
        segmentConditions.push(like(customers.anaBrans, `%Seyahat%`));
      }
      if (segmentLower.includes("nakliyat")) {
        segmentConditions.push(like(customers.anaBrans, `%Nakliyat%`));
      }
      if (segmentLower.includes("isyeri") || segmentLower.includes("işyeri")) {
        segmentConditions.push(like(customers.anaBrans, `%İşyeri%`));
        segmentConditions.push(like(customers.anaBrans, `%Isyeri%`));
      }
      if (segmentLower.includes("ferdi") || segmentLower.includes("kaza")) {
        segmentConditions.push(like(customers.anaBrans, `%Ferdi%`));
        segmentConditions.push(like(customers.anaBrans, `%Kaza%`));
      }
      
      console.log("[DEBUG] Segment conditions count:", segmentConditions.length);
      if (segmentConditions.length > 0) {
        conditions.push(or(...segmentConditions));
      }
    }
    
    // Has branch filter - customers who have this product/branch
    // Uses tcKimlikNo to group policies by customer
    if (filters.hasBranch) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND ${customers.tcKimlikNo} IN (
          SELECT tc_kimlik_no FROM customers 
          WHERE ana_brans ILIKE ${`%${filters.hasBranch}%`} AND tc_kimlik_no IS NOT NULL
        )`
      );
    }
    
    // Not has branch filter - customers who do NOT have this product/branch
    // Uses NOT EXISTS instead of NOT IN to handle NULL values properly
    if (filters.notHasBranch) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND NOT EXISTS (
          SELECT 1 FROM customers c2 
          WHERE c2.tc_kimlik_no = ${customers.tcKimlikNo}
          AND c2.ana_brans ILIKE ${`%${filters.notHasBranch}%`}
        )`
      );
    }
    
    // Age filter - customers older than X years based on dogumTarihi
    if (filters.minAge) {
      conditions.push(
        sql`${customers.dogumTarihi} IS NOT NULL AND 
            date_part('year', age(CURRENT_DATE, ${customers.dogumTarihi}::date)) >= ${filters.minAge}`
      );
    }
    
    // Second has branch filter for multi-product queries (e.g., Trafik + Konut)
    if (filters.hasBranch2) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND ${customers.tcKimlikNo} IN (
          SELECT tc_kimlik_no FROM customers 
          WHERE ana_brans ILIKE ${`%${filters.hasBranch2}%`} AND tc_kimlik_no IS NOT NULL
        )`
      );
    }
    
    // Second not has branch filter for multi-product exclusion
    if (filters.notHasBranch2) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND NOT EXISTS (
          SELECT 1 FROM customers c2 
          WHERE c2.tc_kimlik_no = ${customers.tcKimlikNo}
          AND c2.ana_brans ILIKE ${`%${filters.notHasBranch2}%`}
        )`
      );
    }
    
    // Policy count filter - filter customers by number of policies they have
    if (filters.policyCountMin !== undefined || filters.policyCountMax !== undefined) {
      const minCount = filters.policyCountMin || 0;
      const maxCount = filters.policyCountMax || 999999;
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND ${customers.tcKimlikNo} IN (
          SELECT tc_kimlik_no FROM customers 
          WHERE tc_kimlik_no IS NOT NULL
          GROUP BY tc_kimlik_no 
          HAVING COUNT(DISTINCT police_numarasi) >= ${minCount} 
             AND COUNT(DISTINCT police_numarasi) <= ${maxCount}
        )`
      );
    }
    
    // Product-specific renewal filter - policies of specific branch expiring within X days
    if (filters.renewalProduct) {
      const renewalDays = filters.renewalDays || 30;
      conditions.push(
        sql`${customers.anaBrans} ILIKE ${`%${filters.renewalProduct}%`}
            AND ${customers.bitisTarihi} IS NOT NULL
            AND ${customers.bitisTarihi}::date >= CURRENT_DATE
            AND ${customers.bitisTarihi}::date <= CURRENT_DATE + ${renewalDays}::integer`
      );
    }
    
    // Vehicle count filter - customers with multiple vehicles (by distinct plate count)
    if (filters.vehicleCountMin !== undefined && filters.vehicleCountMin > 1) {
      conditions.push(
        sql`${customers.tcKimlikNo} IS NOT NULL AND ${customers.tcKimlikNo} IN (
          SELECT tc_kimlik_no FROM customers 
          WHERE tc_kimlik_no IS NOT NULL AND arac_plakasi IS NOT NULL AND arac_plakasi != ''
          GROUP BY tc_kimlik_no 
          HAVING COUNT(DISTINCT arac_plakasi) >= ${filters.vehicleCountMin}
        )`
      );
    }
    
    // Vehicle age filter - customers with vehicles newer than X years (based on model_yili)
    if (filters.vehicleAgeMax !== undefined) {
      const currentYear = new Date().getFullYear();
      const minModelYear = currentYear - filters.vehicleAgeMax;
      conditions.push(
        sql`${customers.modelYili} IS NOT NULL AND ${customers.modelYili} >= ${minModelYear}`
      );
    }

    const offset = (filters.page - 1) * filters.limit;
    
    const countResult = await db
      .select({ count: sql<number>`count(*)` })
      .from(customers)
      .where(conditions.length > 0 ? and(...conditions) : undefined);
    
    const total = Number(countResult[0]?.count || 0);
    
    const data = await db
      .select()
      .from(customers)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(customers.musteriIsmi)
      .limit(filters.limit)
      .offset(offset);

    return {
      customers: data,
      total,
      page: filters.page,
      totalPages: Math.ceil(total / filters.limit),
    };
  }
  
  // Customer Profile Methods
  async getDistinctPolicyTypes(): Promise<string[]> {
    const result = await db
      .selectDistinct({ policeTuru: customers.policeTuru })
      .from(customers)
      .where(isNotNull(customers.policeTuru))
      .orderBy(customers.policeTuru);
    
    return result.map(r => r.policeTuru).filter((v): v is string => v !== null);
  }

  async getCustomerProfilesPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    customerType?: string;
    policyType?: string;
    hashtags?: string[];
    product?: string;
    vehicleBrand?: string;
    hasAiAnalysis?: boolean;
    hasBranch?: string;
    notHasBranch?: string;
    policyCountMin?: number;
    policyCountMax?: number;
    vehicleCountMin?: number;
    vehicleAgeMax?: number;
  }): Promise<{ profiles: CustomerProfile[]; total: number; page: number; totalPages: number }> {
    const conditions = [];
    
    if (filters.search) {
      conditions.push(
        or(
          ilike(customerProfiles.musteriIsmi, `%${filters.search}%`),
          ilike(customerProfiles.hesapKodu, `%${filters.search}%`),
          ilike(customerProfiles.tcKimlikNo, `%${filters.search}%`),
          ilike(customerProfiles.vergiKimlikNo, `%${filters.search}%`),
          ilike(customerProfiles.ePosta, `%${filters.search}%`),
          ilike(customerProfiles.gsmNo, `%${filters.search}%`)
        )
      );
    }
    
    if (filters.city && filters.city !== "all") {
      conditions.push(ilike(customerProfiles.sehir, `%${filters.city}%`));
    }
    
    if (filters.customerType && filters.customerType !== "all") {
      conditions.push(ilike(customerProfiles.musteriTipi, `%${filters.customerType}%`));
    }
    
    if (filters.hashtags && filters.hashtags.length > 0) {
      for (const hashtag of filters.hashtags) {
        if (hashtag && hashtag !== "all") {
          conditions.push(ilike(customerProfiles.aiAnaliz, `%${hashtag}%`));
        }
      }
    }
    
    if (filters.product && filters.product !== "all") {
      conditions.push(ilike(customerProfiles.sahipOlunanUrunler, `%${filters.product}%`));
    }
    
    if (filters.vehicleBrand && filters.vehicleBrand !== "all") {
      conditions.push(ilike(customerProfiles.aracBilgileri, `%${filters.vehicleBrand}%`));
    }
    
    if (filters.hasAiAnalysis) {
      conditions.push(isNotNull(customerProfiles.aiAnaliz));
    }
    
    if (filters.policyType && filters.policyType !== "all") {
      conditions.push(ilike(customerProfiles.sahipOlunanPoliceTurleri, `%${filters.policyType}%`));
    }
    
    // Backend normalization: map display names to raw branch keys
    const branchDisplayToRaw: Record<string, string> = {
      "Oto Kaza (Kasko)": "Kasko",
      "Oto Kaza (Trafik)": "Trafik",
      "Dask": "DASK",
      "Sağlık": "Sağlık",
      "Yangın (Konut)": "Konut",
      "Seyahat Sağlık": "Seyahat",
      "Ferdi Kaza": "Ferdi Kaza",
      "Nakliyat": "Nakliyat",
      "Yangın (İşyeri)": "İşyeri",
      "Mühendislik": "Mühendislik",
      "Sorumluluk": "Sorumluluk",
      "Hayat": "Hayat",
    };
    
    // hasBranch: customer must have this product (search in sahipOlunanUrunler)
    if (filters.hasBranch) {
      const normalizedBranch = branchDisplayToRaw[filters.hasBranch] || filters.hasBranch;
      conditions.push(ilike(customerProfiles.sahipOlunanUrunler, `%${normalizedBranch}%`));
    }
    
    // notHasBranch: customer must NOT have this product
    if (filters.notHasBranch) {
      const normalizedBranch = branchDisplayToRaw[filters.notHasBranch] || filters.notHasBranch;
      conditions.push(
        or(
          isNull(customerProfiles.sahipOlunanUrunler),
          not(ilike(customerProfiles.sahipOlunanUrunler, `%${normalizedBranch}%`))
        )
      );
    }
    
    // policyCountMin: minimum number of policies
    if (filters.policyCountMin !== undefined) {
      conditions.push(gte(customerProfiles.toplamPolice, filters.policyCountMin));
    }
    
    // policyCountMax: maximum number of policies
    if (filters.policyCountMax !== undefined) {
      conditions.push(lte(customerProfiles.toplamPolice, filters.policyCountMax));
    }
    
    // vehicleCountMin: minimum number of vehicles
    if (filters.vehicleCountMin !== undefined) {
      conditions.push(gte(customerProfiles.aracSayisi, filters.vehicleCountMin));
    }
    
    // vehicleAgeMax: Handled in Node.js post-processing for stability
    // SQL-based JSON parsing is unsafe due to unreliable data quality
    const vehicleAgeMax = filters.vehicleAgeMax;
    
    // If vehicleAgeMax is specified, we need to fetch all matching profiles and filter in Node.js
    if (vehicleAgeMax !== undefined && Number.isFinite(vehicleAgeMax) && vehicleAgeMax >= 0) {
      // Fetch all profiles matching SQL conditions (without vehicleAgeMax)
      const allData = await db
        .select()
        .from(customerProfiles)
        .where(conditions.length > 0 ? and(...conditions) : undefined)
        .orderBy(customerProfiles.musteriIsmi);
      
      // Filter in Node.js by parsing aracBilgileri safely
      const currentYear = new Date().getFullYear();
      const minYear = currentYear - vehicleAgeMax;
      
      const filteredData = allData.filter(profile => {
        if (!profile.aracBilgileri) return false;
        try {
          const vehicles = JSON.parse(profile.aracBilgileri);
          if (!Array.isArray(vehicles)) return false;
          return vehicles.some((v: { yil?: number | string }) => {
            const year = typeof v.yil === 'string' ? parseInt(v.yil, 10) : v.yil;
            return typeof year === 'number' && !isNaN(year) && year >= minYear;
          });
        } catch {
          return false;
        }
      });
      
      // Apply pagination on filtered results
      const total = filteredData.length;
      const offset = (filters.page - 1) * filters.limit;
      const paginatedData = filteredData.slice(offset, offset + filters.limit);
      
      return {
        profiles: paginatedData,
        total,
        page: filters.page,
        totalPages: Math.ceil(total / filters.limit),
      };
    }
    
    // Standard SQL-based pagination for other filters
    const offset = (filters.page - 1) * filters.limit;
    
    const countResult = await db
      .select({ count: sql<number>`count(*)` })
      .from(customerProfiles)
      .where(conditions.length > 0 ? and(...conditions) : undefined);
    
    const total = Number(countResult[0]?.count || 0);
    
    const data = await db
      .select()
      .from(customerProfiles)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(customerProfiles.musteriIsmi)
      .limit(filters.limit)
      .offset(offset);
    
    return {
      profiles: data,
      total,
      page: filters.page,
      totalPages: Math.ceil(total / filters.limit),
    };
  }
  
  async getCustomerProfile(id: string): Promise<CustomerProfile | undefined> {
    const [profile] = await db.select().from(customerProfiles).where(eq(customerProfiles.id, id));
    return profile;
  }
  
  async getCustomerProfileByHesapKodu(hesapKodu: string): Promise<CustomerProfile | undefined> {
    const [profile] = await db.select().from(customerProfiles).where(eq(customerProfiles.hesapKodu, hesapKodu));
    return profile;
  }
  
  async getCustomerPolicies(hesapKodu: string): Promise<Customer[]> {
    return await db
      .select()
      .from(customers)
      .where(eq(customers.hesapKodu, hesapKodu))
      .orderBy(customers.bitisTarihi);
  }
  
  async syncCustomerProfiles(): Promise<{ created: number; updated: number }> {
    // Get unique customers by hesap_kodu with aggregated data
    const aggregatedData = await db.execute(sql`
      WITH customer_agg AS (
        SELECT 
          hesap_kodu,
          MAX(musteri_ismi) as musteri_ismi,
          MAX(musteri_tipi) as musteri_tipi,
          MAX(tc_kimlik_no) as tc_kimlik_no,
          MAX(vergi_kimlik_no) as vergi_kimlik_no,
          MAX(telefon_1) as telefon_1,
          MAX(telefon_2) as telefon_2,
          MAX(gsm_no) as gsm_no,
          MAX(e_posta) as e_posta,
          MAX(faks_no) as faks_no,
          MAX(sehir) as sehir,
          MAX(semt) as semt,
          MAX(ilce) as ilce,
          MAX(adres_1) as adres_1,
          MAX(adres_2) as adres_2,
          MAX(dogum_tarihi) as dogum_tarihi,
          MAX(cinsiyet) as cinsiyet,
          MAX(meslek_grubu) as meslek_grubu,
          MAX(referans_grubu) as referans_grubu,
          MAX(musteri_karti_tipi) as musteri_karti_tipi,
          MAX(alternatif_hesap_kodu) as alternatif_hesap_kodu,
          MAX(hesap_temsilci_adi) as hesap_temsilci_adi,
          MAX(sube_adi) as sube_adi,
          MAX(izinli_pazarlama) as izinli_pazarlama,
          MAX(kvkk) as kvkk,
          COUNT(*) as toplam_police,
          COUNT(*) FILTER (WHERE bitis_tarihi::date >= CURRENT_DATE) as aktif_police,
          COALESCE(SUM(CASE WHEN brut::numeric > 0 THEN brut::numeric ELSE 0 END), 0) as toplam_brut_prim,
          COALESCE(SUM(CASE WHEN net::numeric > 0 THEN net::numeric ELSE 0 END), 0) as toplam_net_prim,
          STRING_AGG(DISTINCT ana_brans, ', ') as sahip_olunan_urunler,
          STRING_AGG(DISTINCT police_turu, ', ') as sahip_olunan_police_turleri,
          COUNT(DISTINCT arac_plakasi) FILTER (WHERE arac_plakasi IS NOT NULL AND arac_plakasi != '') as arac_sayisi,
          (
            SELECT json_agg(DISTINCT jsonb_build_object('marka', arac_markasi, 'model', arac_modeli, 'yil', model_yili))
            FROM customers c2 
            WHERE c2.hesap_kodu = customers.hesap_kodu 
              AND c2.arac_markasi IS NOT NULL AND c2.arac_markasi != ''
          ) as arac_bilgileri
        FROM customers
        WHERE hesap_kodu IS NOT NULL AND hesap_kodu != ''
        GROUP BY hesap_kodu
      )
      SELECT * FROM customer_agg
    `);
    
    let created = 0;
    let updated = 0;
    
    for (const row of aggregatedData.rows as any[]) {
      const existingProfile = await this.getCustomerProfileByHesapKodu(row.hesap_kodu);
      
      const profileData: InsertCustomerProfile = {
        hesapKodu: row.hesap_kodu,
        musteriIsmi: row.musteri_ismi,
        musteriTipi: row.musteri_tipi,
        tcKimlikNo: row.tc_kimlik_no,
        vergiKimlikNo: row.vergi_kimlik_no,
        telefon1: row.telefon_1,
        telefon2: row.telefon_2,
        gsmNo: row.gsm_no,
        ePosta: row.e_posta,
        faksNo: row.faks_no,
        sehir: row.sehir,
        semt: row.semt,
        ilce: row.ilce,
        adres1: row.adres_1,
        adres2: row.adres_2,
        dogumTarihi: row.dogum_tarihi,
        cinsiyet: row.cinsiyet,
        meslekGrubu: row.meslek_grubu,
        referansGrubu: row.referans_grubu,
        musteriKartiTipi: row.musteri_karti_tipi,
        alternatifHesapKodu: row.alternatif_hesap_kodu,
        hesapTemsilciAdi: row.hesap_temsilci_adi,
        subeAdi: row.sube_adi,
        izinliPazarlama: row.izinli_pazarlama,
        kvkk: row.kvkk,
        toplamPolice: parseInt(row.toplam_police) || 0,
        aktifPolice: parseInt(row.aktif_police) || 0,
        toplamBrutPrim: row.toplam_brut_prim?.toString() || "0",
        toplamNetPrim: row.toplam_net_prim?.toString() || "0",
        sahipOlunanUrunler: row.sahip_olunan_urunler,
        sahipOlunanPoliceTurleri: row.sahip_olunan_police_turleri,
        aracSayisi: parseInt(row.arac_sayisi) || 0,
        aracBilgileri: row.arac_bilgileri ? JSON.stringify(row.arac_bilgileri) : null,
      };
      
      if (existingProfile) {
        await db
          .update(customerProfiles)
          .set({ ...profileData, updatedAt: new Date() })
          .where(eq(customerProfiles.id, existingProfile.id));
        updated++;
      } else {
        await db.insert(customerProfiles).values(profileData);
        created++;
      }
    }
    
    return { created, updated };
  }
  
  async updateProfileAiAnalysis(profileId: string, aiAnaliz: string): Promise<void> {
    await db
      .update(customerProfiles)
      .set({ 
        aiAnaliz, 
        aiAnalizTarihi: new Date(),
        updatedAt: new Date() 
      })
      .where(eq(customerProfiles.id, profileId));
  }
  
  async getAllCustomerProfilesForAiAnalysis(): Promise<CustomerProfile[]> {
    return await db
      .select()
      .from(customerProfiles)
      .orderBy(customerProfiles.musteriIsmi);
  }
}

export const storage = new DatabaseStorage();
