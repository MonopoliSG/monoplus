import {
  users,
  customers,
  products,
  segments,
  campaigns,
  aiAnalyses,
  aiCustomerPredictions,
  type User,
  type UpsertUser,
  type Customer,
  type InsertCustomer,
  type Product,
  type InsertProduct,
  type Segment,
  type InsertSegment,
  type Campaign,
  type InsertCampaign,
  type AiAnalysis,
  type InsertAiAnalysis,
  type AiCustomerPrediction,
  type InsertAiCustomerPrediction,
} from "@shared/schema";
import { db } from "./db";
import { eq, sql, and, gte, lte, like, or, inArray } from "drizzle-orm";

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  
  getAllCustomers(): Promise<Customer[]>;
  getCustomer(id: string): Promise<Customer | undefined>;
  getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined>;
  createCustomer(customer: InsertCustomer): Promise<Customer>;
  updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer>;
  upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }>;
  getCustomersWithRenewalIn30Days(): Promise<Customer[]>;
  getCustomersByIds(ids: string[]): Promise<Customer[]>;
  getCustomerCount(): Promise<number>;
  
  getAllProducts(): Promise<Product[]>;
  getProduct(id: string): Promise<Product | undefined>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product>;
  deleteProduct(id: string): Promise<void>;
  getProductCustomerCounts(): Promise<Record<string, number>>;
  
  getAllSegments(): Promise<Segment[]>;
  getSegment(id: string): Promise<Segment | undefined>;
  createSegment(segment: InsertSegment): Promise<Segment>;
  updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment>;
  deleteSegment(id: string): Promise<void>;
  deleteAutoGeneratedSegments(): Promise<void>;
  
  getAllCampaigns(): Promise<Campaign[]>;
  getCampaign(id: string): Promise<Campaign | undefined>;
  createCampaign(campaign: InsertCampaign): Promise<Campaign>;
  updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign>;
  deleteCampaign(id: string): Promise<void>;
  
  getAllAiAnalyses(): Promise<AiAnalysis[]>;
  createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis>;
  deleteAiAnalysesByType(analysisType: string): Promise<void>;
  
  getCustomerPredictions(filters: {
    analysisType?: string;
    minProbability?: number;
    maxProbability?: number;
    search?: string;
    product?: string;
    city?: string;
  }): Promise<AiCustomerPrediction[]>;
  getCustomerPredictionsByCustomerId(customerId: string): Promise<AiCustomerPrediction[]>;
  createCustomerPredictions(predictions: InsertAiCustomerPrediction[]): Promise<AiCustomerPrediction[]>;
  deleteCustomerPredictionsByType(analysisType: string): Promise<void>;
  
  getCustomersPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    branch?: string;
    segment?: string;
  }): Promise<{ customers: Customer[]; total: number; page: number; totalPages: number }>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  async getAllCustomers(): Promise<Customer[]> {
    return await db.select().from(customers).orderBy(customers.musteriIsmi);
  }

  async getCustomer(id: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.id, id));
    return customer;
  }

  async getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.tcKimlikNo, tcKimlik));
    return customer;
  }

  async createCustomer(customer: InsertCustomer): Promise<Customer> {
    const [newCustomer] = await db.insert(customers).values(customer).returning();
    return newCustomer;
  }

  async updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer> {
    const [updated] = await db
      .update(customers)
      .set({ ...customer, updatedAt: new Date() })
      .where(eq(customers.id, id))
      .returning();
    return updated;
  }

  async upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }> {
    if (!customer.tcKimlikNo) {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }

    const existing = await this.getCustomerByTcKimlik(customer.tcKimlikNo);
    if (existing) {
      const updated = await this.updateCustomer(existing.id, customer);
      return { customer: updated, isNew: false };
    } else {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }
  }

  async getCustomersWithRenewalIn30Days(): Promise<Customer[]> {
    const today = new Date();
    const thirtyDaysLater = new Date();
    thirtyDaysLater.setDate(today.getDate() + 30);

    return await db
      .select()
      .from(customers)
      .where(
        and(
          gte(customers.bitisTarihi, today.toISOString().split("T")[0]),
          lte(customers.bitisTarihi, thirtyDaysLater.toISOString().split("T")[0])
        )
      );
  }

  async getCustomersByIds(ids: string[]): Promise<Customer[]> {
    if (ids.length === 0) return [];
    return await db.select().from(customers).where(inArray(customers.id, ids));
  }

  async getCustomerCount(): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` }).from(customers);
    return Number(result[0]?.count || 0);
  }

  async getAllProducts(): Promise<Product[]> {
    return await db.select().from(products).orderBy(products.name);
  }

  async getProduct(id: string): Promise<Product | undefined> {
    const [product] = await db.select().from(products).where(eq(products.id, id));
    return product;
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    const [newProduct] = await db.insert(products).values(product).returning();
    return newProduct;
  }

  async updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product> {
    const [updated] = await db
      .update(products)
      .set({ ...product, updatedAt: new Date() })
      .where(eq(products.id, id))
      .returning();
    return updated;
  }

  async deleteProduct(id: string): Promise<void> {
    await db.delete(products).where(eq(products.id, id));
  }

  async getProductCustomerCounts(): Promise<Record<string, number>> {
    const result = await db
      .select({
        anaBrans: customers.anaBrans,
        count: sql<number>`count(*)`,
      })
      .from(customers)
      .groupBy(customers.anaBrans);

    const counts: Record<string, number> = {};
    for (const row of result) {
      if (row.anaBrans) {
        counts[row.anaBrans] = Number(row.count);
      }
    }
    return counts;
  }

  async getAllSegments(): Promise<Segment[]> {
    return await db.select().from(segments).orderBy(segments.createdAt);
  }

  async getSegment(id: string): Promise<Segment | undefined> {
    const [segment] = await db.select().from(segments).where(eq(segments.id, id));
    return segment;
  }

  async createSegment(segment: InsertSegment): Promise<Segment> {
    const [newSegment] = await db.insert(segments).values(segment).returning();
    return newSegment;
  }

  async updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment> {
    const [updated] = await db
      .update(segments)
      .set({ ...segment, updatedAt: new Date() })
      .where(eq(segments.id, id))
      .returning();
    return updated;
  }

  async deleteSegment(id: string): Promise<void> {
    await db.delete(segments).where(eq(segments.id, id));
  }

  async deleteAutoGeneratedSegments(): Promise<void> {
    await db.delete(segments).where(eq(segments.isAutoGenerated, true));
  }

  async getAllCampaigns(): Promise<Campaign[]> {
    return await db.select().from(campaigns).orderBy(campaigns.createdAt);
  }

  async getCampaign(id: string): Promise<Campaign | undefined> {
    const [campaign] = await db.select().from(campaigns).where(eq(campaigns.id, id));
    return campaign;
  }

  async createCampaign(campaign: InsertCampaign): Promise<Campaign> {
    const [newCampaign] = await db.insert(campaigns).values(campaign).returning();
    return newCampaign;
  }

  async updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign> {
    const [updated] = await db
      .update(campaigns)
      .set({ ...campaign, updatedAt: new Date() })
      .where(eq(campaigns.id, id))
      .returning();
    return updated;
  }

  async deleteCampaign(id: string): Promise<void> {
    await db.delete(campaigns).where(eq(campaigns.id, id));
  }

  async getAllAiAnalyses(): Promise<AiAnalysis[]> {
    return await db.select().from(aiAnalyses).where(eq(aiAnalyses.isActive, true));
  }

  async createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis> {
    const [newAnalysis] = await db.insert(aiAnalyses).values(analysis).returning();
    return newAnalysis;
  }

  async deleteAiAnalysesByType(analysisType: string): Promise<void> {
    await db.delete(aiAnalyses).where(eq(aiAnalyses.analysisType, analysisType));
  }

  async getCustomerPredictions(filters: {
    analysisType?: string;
    minProbability?: number;
    maxProbability?: number;
    search?: string;
    product?: string;
    city?: string;
  }): Promise<AiCustomerPrediction[]> {
    const conditions = [];
    
    if (filters.analysisType) {
      conditions.push(eq(aiCustomerPredictions.analysisType, filters.analysisType));
    }
    if (filters.minProbability !== undefined) {
      conditions.push(gte(aiCustomerPredictions.probability, filters.minProbability));
    }
    if (filters.maxProbability !== undefined) {
      conditions.push(lte(aiCustomerPredictions.probability, filters.maxProbability));
    }
    if (filters.search) {
      conditions.push(like(aiCustomerPredictions.customerName, `%${filters.search}%`));
    }
    if (filters.product) {
      conditions.push(eq(aiCustomerPredictions.currentProduct, filters.product));
    }
    if (filters.city) {
      conditions.push(eq(aiCustomerPredictions.city, filters.city));
    }

    if (conditions.length === 0) {
      return await db.select().from(aiCustomerPredictions).orderBy(sql`${aiCustomerPredictions.probability} DESC`);
    }
    
    return await db
      .select()
      .from(aiCustomerPredictions)
      .where(and(...conditions))
      .orderBy(sql`${aiCustomerPredictions.probability} DESC`);
  }

  async getCustomerPredictionsByCustomerId(customerId: string): Promise<AiCustomerPrediction[]> {
    return await db
      .select()
      .from(aiCustomerPredictions)
      .where(eq(aiCustomerPredictions.customerId, customerId))
      .orderBy(sql`${aiCustomerPredictions.probability} DESC`);
  }

  async createCustomerPredictions(predictions: InsertAiCustomerPrediction[]): Promise<AiCustomerPrediction[]> {
    if (predictions.length === 0) return [];
    return await db.insert(aiCustomerPredictions).values(predictions).returning();
  }

  async deleteCustomerPredictionsByType(analysisType: string): Promise<void> {
    await db.delete(aiCustomerPredictions).where(eq(aiCustomerPredictions.analysisType, analysisType));
  }

  async getCustomersPaginated(filters: {
    page: number;
    limit: number;
    search?: string;
    city?: string;
    branch?: string;
    segment?: string;
  }): Promise<{ customers: Customer[]; total: number; page: number; totalPages: number }> {
    const conditions = [];

    if (filters.search) {
      conditions.push(
        or(
          like(customers.musteriIsmi, `%${filters.search}%`),
          like(customers.tcKimlikNo, `%${filters.search}%`),
          like(customers.gsmNo, `%${filters.search}%`)
        )
      );
    }
    if (filters.city) {
      conditions.push(eq(customers.sehir, filters.city));
    }
    if (filters.branch) {
      conditions.push(eq(customers.anaBrans, filters.branch));
    }
    if (filters.segment) {
      const segmentLower = filters.segment.toLowerCase();
      const segmentConditions: any[] = [];
      
      if (segmentLower.includes("kurumsal")) {
        segmentConditions.push(like(customers.firmaTipi, `%tüzel%`));
      }
      if (segmentLower.includes("bireysel")) {
        segmentConditions.push(like(customers.firmaTipi, `%gerçek%`));
      }
      if (segmentLower.includes("trafik")) {
        segmentConditions.push(like(customers.anaBrans, `%trafik%`));
      }
      if (segmentLower.includes("kasko")) {
        segmentConditions.push(like(customers.anaBrans, `%kasko%`));
      }
      if (segmentLower.includes("sağlık")) {
        segmentConditions.push(like(customers.anaBrans, `%sağlık%`));
      }
      if (segmentLower.includes("dask")) {
        segmentConditions.push(like(customers.anaBrans, `%dask%`));
      }
      if (segmentLower.includes("yangın") || segmentLower.includes("konut")) {
        segmentConditions.push(like(customers.anaBrans, `%yangın%`));
        segmentConditions.push(like(customers.anaBrans, `%konut%`));
      }
      if (segmentLower.includes("mühendislik")) {
        segmentConditions.push(like(customers.anaBrans, `%mühendislik%`));
      }
      if (segmentConditions.length > 0) {
        conditions.push(or(...segmentConditions));
      }
    }

    const offset = (filters.page - 1) * filters.limit;
    
    const countResult = await db
      .select({ count: sql<number>`count(*)` })
      .from(customers)
      .where(conditions.length > 0 ? and(...conditions) : undefined);
    
    const total = Number(countResult[0]?.count || 0);
    
    const data = await db
      .select()
      .from(customers)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(customers.musteriIsmi)
      .limit(filters.limit)
      .offset(offset);

    return {
      customers: data,
      total,
      page: filters.page,
      totalPages: Math.ceil(total / filters.limit),
    };
  }
}

export const storage = new DatabaseStorage();
