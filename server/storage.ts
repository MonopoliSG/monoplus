import {
  users,
  customers,
  products,
  segments,
  campaigns,
  aiAnalyses,
  type User,
  type UpsertUser,
  type Customer,
  type InsertCustomer,
  type Product,
  type InsertProduct,
  type Segment,
  type InsertSegment,
  type Campaign,
  type InsertCampaign,
  type AiAnalysis,
  type InsertAiAnalysis,
} from "@shared/schema";
import { db } from "./db";
import { eq, sql, and, gte, lte, like, or, inArray } from "drizzle-orm";

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  
  getAllCustomers(): Promise<Customer[]>;
  getCustomer(id: string): Promise<Customer | undefined>;
  getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined>;
  createCustomer(customer: InsertCustomer): Promise<Customer>;
  updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer>;
  upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }>;
  getCustomersWithRenewalIn30Days(): Promise<Customer[]>;
  getCustomersByIds(ids: string[]): Promise<Customer[]>;
  getCustomerCount(): Promise<number>;
  
  getAllProducts(): Promise<Product[]>;
  getProduct(id: string): Promise<Product | undefined>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product>;
  deleteProduct(id: string): Promise<void>;
  getProductCustomerCounts(): Promise<Record<string, number>>;
  
  getAllSegments(): Promise<Segment[]>;
  getSegment(id: string): Promise<Segment | undefined>;
  createSegment(segment: InsertSegment): Promise<Segment>;
  updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment>;
  deleteSegment(id: string): Promise<void>;
  deleteAutoGeneratedSegments(): Promise<void>;
  
  getAllCampaigns(): Promise<Campaign[]>;
  getCampaign(id: string): Promise<Campaign | undefined>;
  createCampaign(campaign: InsertCampaign): Promise<Campaign>;
  updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign>;
  deleteCampaign(id: string): Promise<void>;
  
  getAllAiAnalyses(): Promise<AiAnalysis[]>;
  createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis>;
  deleteAiAnalysesByType(analysisType: string): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  async getAllCustomers(): Promise<Customer[]> {
    return await db.select().from(customers).orderBy(customers.unvan);
  }

  async getCustomer(id: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.id, id));
    return customer;
  }

  async getCustomerByTcKimlik(tcKimlik: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.tcKimlikNo, tcKimlik));
    return customer;
  }

  async createCustomer(customer: InsertCustomer): Promise<Customer> {
    const [newCustomer] = await db.insert(customers).values(customer).returning();
    return newCustomer;
  }

  async updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer> {
    const [updated] = await db
      .update(customers)
      .set({ ...customer, updatedAt: new Date() })
      .where(eq(customers.id, id))
      .returning();
    return updated;
  }

  async upsertCustomerByTcKimlik(customer: InsertCustomer): Promise<{ customer: Customer; isNew: boolean }> {
    if (!customer.tcKimlikNo) {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }

    const existing = await this.getCustomerByTcKimlik(customer.tcKimlikNo);
    if (existing) {
      const updated = await this.updateCustomer(existing.id, customer);
      return { customer: updated, isNew: false };
    } else {
      const newCustomer = await this.createCustomer(customer);
      return { customer: newCustomer, isNew: true };
    }
  }

  async getCustomersWithRenewalIn30Days(): Promise<Customer[]> {
    const today = new Date();
    const thirtyDaysLater = new Date();
    thirtyDaysLater.setDate(today.getDate() + 30);

    return await db
      .select()
      .from(customers)
      .where(
        and(
          gte(customers.policeBitisTarihi, today.toISOString().split("T")[0]),
          lte(customers.policeBitisTarihi, thirtyDaysLater.toISOString().split("T")[0])
        )
      );
  }

  async getCustomersByIds(ids: string[]): Promise<Customer[]> {
    if (ids.length === 0) return [];
    return await db.select().from(customers).where(inArray(customers.id, ids));
  }

  async getCustomerCount(): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` }).from(customers);
    return Number(result[0]?.count || 0);
  }

  async getAllProducts(): Promise<Product[]> {
    return await db.select().from(products).orderBy(products.name);
  }

  async getProduct(id: string): Promise<Product | undefined> {
    const [product] = await db.select().from(products).where(eq(products.id, id));
    return product;
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    const [newProduct] = await db.insert(products).values(product).returning();
    return newProduct;
  }

  async updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product> {
    const [updated] = await db
      .update(products)
      .set({ ...product, updatedAt: new Date() })
      .where(eq(products.id, id))
      .returning();
    return updated;
  }

  async deleteProduct(id: string): Promise<void> {
    await db.delete(products).where(eq(products.id, id));
  }

  async getProductCustomerCounts(): Promise<Record<string, number>> {
    const result = await db
      .select({
        anaBrans: customers.anaBrans,
        count: sql<number>`count(*)`,
      })
      .from(customers)
      .groupBy(customers.anaBrans);

    const counts: Record<string, number> = {};
    for (const row of result) {
      if (row.anaBrans) {
        counts[row.anaBrans] = Number(row.count);
      }
    }
    return counts;
  }

  async getAllSegments(): Promise<Segment[]> {
    return await db.select().from(segments).orderBy(segments.createdAt);
  }

  async getSegment(id: string): Promise<Segment | undefined> {
    const [segment] = await db.select().from(segments).where(eq(segments.id, id));
    return segment;
  }

  async createSegment(segment: InsertSegment): Promise<Segment> {
    const [newSegment] = await db.insert(segments).values(segment).returning();
    return newSegment;
  }

  async updateSegment(id: string, segment: Partial<InsertSegment>): Promise<Segment> {
    const [updated] = await db
      .update(segments)
      .set({ ...segment, updatedAt: new Date() })
      .where(eq(segments.id, id))
      .returning();
    return updated;
  }

  async deleteSegment(id: string): Promise<void> {
    await db.delete(segments).where(eq(segments.id, id));
  }

  async deleteAutoGeneratedSegments(): Promise<void> {
    await db.delete(segments).where(eq(segments.isAutoGenerated, true));
  }

  async getAllCampaigns(): Promise<Campaign[]> {
    return await db.select().from(campaigns).orderBy(campaigns.createdAt);
  }

  async getCampaign(id: string): Promise<Campaign | undefined> {
    const [campaign] = await db.select().from(campaigns).where(eq(campaigns.id, id));
    return campaign;
  }

  async createCampaign(campaign: InsertCampaign): Promise<Campaign> {
    const [newCampaign] = await db.insert(campaigns).values(campaign).returning();
    return newCampaign;
  }

  async updateCampaign(id: string, campaign: Partial<InsertCampaign>): Promise<Campaign> {
    const [updated] = await db
      .update(campaigns)
      .set({ ...campaign, updatedAt: new Date() })
      .where(eq(campaigns.id, id))
      .returning();
    return updated;
  }

  async deleteCampaign(id: string): Promise<void> {
    await db.delete(campaigns).where(eq(campaigns.id, id));
  }

  async getAllAiAnalyses(): Promise<AiAnalysis[]> {
    return await db.select().from(aiAnalyses).where(eq(aiAnalyses.isActive, true));
  }

  async createAiAnalysis(analysis: InsertAiAnalysis): Promise<AiAnalysis> {
    const [newAnalysis] = await db.insert(aiAnalyses).values(analysis).returning();
    return newAnalysis;
  }

  async deleteAiAnalysesByType(analysisType: string): Promise<void> {
    await db.delete(aiAnalyses).where(eq(aiAnalyses.analysisType, analysisType));
  }
}

export const storage = new DatabaseStorage();
